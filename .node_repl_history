.exit
. exit
cd
console.log(newTree)
  // newTree.left = null;
  // newTree.right = null;
  // newTree.value = 7
  const newTree = new BinarySearchTree(7);
  //
  } 
    //if this.right is null
    // }
    //   if (value > this.right) // recursion here
    // if (this.right !== null) {
    // if (this.right === null) this.right = value;
    //if true, go down right path
    //var = this.right
  if (!holdVal) this.right = value;
  console.log(holdVal);
  while (value > holdVal) holdVal.right = this.right;
    console.log(holdVal);
    // holdVal = this.right;
  // if (value > this.value) {
  //if the value passed in as arg > this.value
  //temp var set this.left
  //temp var set to this.right
  let holdVal = this.value;
  console.log(newNode);
  const newNode = new BinarySearchTree(value);
  if (this.value === value) return;
  // check if value already exists, if true, return
BinarySearchTree.prototype.add = function (value) {
//these data structures lends themselves so well to recursion that they're often referred to as "recursive data structures"
//use recursion on binary serach trees
//quokka does not work well on binary search trees
//each node on a binary search tree IS a binary search tree
//if you're having hiccoughs with data structures, then draw it out, and visually see how they connect
// const emptyTree = new BinarySearchTree();
}
  this.left = null;
  this.right = null;
  this.value = value;
function BinarySearchTree(value) {
.exitcons 
console.log(newTree.add(8));
  // newTree.left = null;
  // newTree.right = null;
  // newTree.value = 7
  const newTree = new BinarySearchTree(7);
  //
  } 
    //if this.right is null
    // }
    //   if (value > this.right) // recursion here
    // if (this.right !== null) {
    // if (this.right === null) this.right = value;
    //if true, go down right path
    //var = this.right
  if (!holdVal) this.right = value;
  console.log(holdVal);
  while (value > holdVal) holdVal.right = this.right;
    console.log(holdVal);
    // holdVal = this.right;
  // if (value > this.value) {
  //if the value passed in as arg > this.value
  //temp var set this.left
  //temp var set to this.right
  let holdVal = this.value;
  console.log(newNode);
  const newNode = new BinarySearchTree(value);
  if (this.value === value) return;
  // check if value already exists, if true, return
BinarySearchTree.prototype.add = function (value) {
//these data structures lends themselves so well to recursion that they're often referred to as "recursive data structures"
//use recursion on binary serach trees
//quokka does not work well on binary search trees
//each node on a binary search tree IS a binary search tree
//if you're having hiccoughs with data structures, then draw it out, and visually see how they connect
// const emptyTree = new BinarySearchTree();
}
  this.left = null;
  this.right = null;
  this.value = value;
function BinarySearchTree(value) {